// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: aexburn/burn.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BurnStats contains cumulative burn statistics
type BurnStats struct {
	// total_burned is the total amount of tokens burned (in base units)
	TotalBurned github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=total_burned,json=totalBurned,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_burned" yaml:"total_burned"`
	// last_burn_rate is the most recently applied burn rate
	LastBurnRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=last_burn_rate,json=lastBurnRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"last_burn_rate" yaml:"last_burn_rate"`
	// last_epoch_number is the epoch when the last burn occurred
	LastEpochNumber uint64 `protobuf:"varint,3,opt,name=last_epoch_number,json=lastEpochNumber,proto3" json:"last_epoch_number,omitempty" yaml:"last_epoch_number"`
	// last_block_height is the block height when the last burn occurred
	LastBlockHeight int64 `protobuf:"varint,4,opt,name=last_block_height,json=lastBlockHeight,proto3" json:"last_block_height,omitempty" yaml:"last_block_height"`
}

func (m *BurnStats) Reset()         { *m = BurnStats{} }
func (m *BurnStats) String() string { return proto.CompactTextString(m) }
func (*BurnStats) ProtoMessage()    {}
func (*BurnStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_806573cb0cb9804e, []int{0}
}
func (m *BurnStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnStats.Merge(m, src)
}
func (m *BurnStats) XXX_Size() int {
	return m.Size()
}
func (m *BurnStats) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnStats.DiscardUnknown(m)
}

var xxx_messageInfo_BurnStats proto.InternalMessageInfo

func (m *BurnStats) GetLastEpochNumber() uint64 {
	if m != nil {
		return m.LastEpochNumber
	}
	return 0
}

func (m *BurnStats) GetLastBlockHeight() int64 {
	if m != nil {
		return m.LastBlockHeight
	}
	return 0
}

// BurnRecord represents a single burn event
type BurnRecord struct {
	// epoch_number is the epoch when the burn occurred
	EpochNumber uint64 `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty" yaml:"epoch_number"`
	// block_height is the block height when the burn occurred
	BlockHeight int64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty" yaml:"block_height"`
	// burned_amount is the amount burned in this event (in base units)
	BurnedAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=burned_amount,json=burnedAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"burned_amount" yaml:"burned_amount"`
	// burn_rate is the burn rate applied in this event
	BurnRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=burn_rate,json=burnRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"burn_rate" yaml:"burn_rate"`
	// gas_usage_rate is the gas usage rate at the time of burn
	GasUsageRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=gas_usage_rate,json=gasUsageRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"gas_usage_rate" yaml:"gas_usage_rate"`
	// total_fees is the total fees collected before burn
	TotalFees github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=total_fees,json=totalFees,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_fees" yaml:"total_fees"`
}

func (m *BurnRecord) Reset()         { *m = BurnRecord{} }
func (m *BurnRecord) String() string { return proto.CompactTextString(m) }
func (*BurnRecord) ProtoMessage()    {}
func (*BurnRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_806573cb0cb9804e, []int{1}
}
func (m *BurnRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnRecord.Merge(m, src)
}
func (m *BurnRecord) XXX_Size() int {
	return m.Size()
}
func (m *BurnRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnRecord.DiscardUnknown(m)
}

var xxx_messageInfo_BurnRecord proto.InternalMessageInfo

func (m *BurnRecord) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *BurnRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// MonthlyBurnData contains burn data for a specific month (for net supply calculation)
type MonthlyBurnData struct {
	// month_index is the index in the rolling 12-month window (0-11)
	MonthIndex uint32 `protobuf:"varint,1,opt,name=month_index,json=monthIndex,proto3" json:"month_index,omitempty" yaml:"month_index"`
	// burned_amount is the total amount burned in this month
	BurnedAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=burned_amount,json=burnedAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"burned_amount" yaml:"burned_amount"`
	// start_height is the starting block height of this month
	StartHeight int64 `protobuf:"varint,3,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty" yaml:"start_height"`
	// end_height is the ending block height of this month
	EndHeight int64 `protobuf:"varint,4,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty" yaml:"end_height"`
}

func (m *MonthlyBurnData) Reset()         { *m = MonthlyBurnData{} }
func (m *MonthlyBurnData) String() string { return proto.CompactTextString(m) }
func (*MonthlyBurnData) ProtoMessage()    {}
func (*MonthlyBurnData) Descriptor() ([]byte, []int) {
	return fileDescriptor_806573cb0cb9804e, []int{2}
}
func (m *MonthlyBurnData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonthlyBurnData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonthlyBurnData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonthlyBurnData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonthlyBurnData.Merge(m, src)
}
func (m *MonthlyBurnData) XXX_Size() int {
	return m.Size()
}
func (m *MonthlyBurnData) XXX_DiscardUnknown() {
	xxx_messageInfo_MonthlyBurnData.DiscardUnknown(m)
}

var xxx_messageInfo_MonthlyBurnData proto.InternalMessageInfo

func (m *MonthlyBurnData) GetMonthIndex() uint32 {
	if m != nil {
		return m.MonthIndex
	}
	return 0
}

func (m *MonthlyBurnData) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *MonthlyBurnData) GetEndHeight() int64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func init() {
	proto.RegisterType((*BurnStats)(nil), "seiprotocol.seichain.aexburn.BurnStats")
	proto.RegisterType((*BurnRecord)(nil), "seiprotocol.seichain.aexburn.BurnRecord")
	proto.RegisterType((*MonthlyBurnData)(nil), "seiprotocol.seichain.aexburn.MonthlyBurnData")
}

func init() { proto.RegisterFile("aexburn/burn.proto", fileDescriptor_806573cb0cb9804e) }

var fileDescriptor_806573cb0cb9804e = []byte{
	// 586 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0x31, 0x6f, 0xd3, 0x40,
	0x14, 0x8e, 0xd3, 0x50, 0xe1, 0x8b, 0xdb, 0x52, 0xd3, 0x82, 0x85, 0x2a, 0xbb, 0xf2, 0x80, 0xb2,
	0x34, 0x16, 0x02, 0x09, 0x29, 0x1b, 0xa6, 0x2d, 0xad, 0x10, 0x0c, 0x46, 0x2c, 0x2c, 0xd6, 0xd9,
	0x3e, 0x6c, 0x2b, 0xb6, 0x2f, 0xf2, 0x9d, 0xa5, 0xe4, 0x5f, 0xf0, 0x27, 0x18, 0xf8, 0x27, 0x1d,
	0x3b, 0x22, 0x06, 0x0b, 0x25, 0xff, 0x20, 0x13, 0x23, 0xba, 0x67, 0x07, 0xdb, 0x74, 0x8a, 0x10,
	0x4b, 0x72, 0xdf, 0x7b, 0xef, 0xbe, 0xef, 0xf3, 0xbd, 0x77, 0x87, 0x54, 0x4c, 0xe6, 0x5e, 0x91,
	0x67, 0x96, 0xf8, 0x19, 0xcf, 0x72, 0xca, 0xa9, 0x7a, 0xc2, 0x48, 0x0c, 0x2b, 0x9f, 0x26, 0x63,
	0x46, 0x62, 0x3f, 0xc2, 0x71, 0x36, 0xae, 0x0b, 0x9f, 0x1c, 0x85, 0x34, 0xa4, 0x90, 0xb6, 0xc4,
	0xaa, 0xda, 0x63, 0xfe, 0xea, 0x23, 0xd9, 0x2e, 0xf2, 0xec, 0x03, 0xc7, 0x9c, 0xa9, 0x11, 0x52,
	0x38, 0xe5, 0x38, 0x71, 0xc5, 0x0e, 0x12, 0x68, 0xd2, 0xa9, 0x34, 0x92, 0xed, 0x8b, 0x9b, 0xd2,
	0xe8, 0xfd, 0x28, 0x8d, 0xa7, 0x61, 0xcc, 0xa3, 0xc2, 0x1b, 0xfb, 0x34, 0xb5, 0x7c, 0xca, 0x52,
	0xca, 0xea, 0xbf, 0x33, 0x16, 0x4c, 0x2d, 0xbe, 0x98, 0x11, 0x36, 0xbe, 0xce, 0xf8, 0xba, 0x34,
	0x1e, 0x2e, 0x70, 0x9a, 0x4c, 0xcc, 0x36, 0x97, 0xe9, 0x0c, 0x01, 0xda, 0x80, 0xd4, 0x14, 0xed,
	0x27, 0x98, 0x71, 0x48, 0xba, 0x39, 0xe6, 0x44, 0xeb, 0x83, 0xd6, 0x9b, 0x2d, 0xb4, 0xce, 0x89,
	0xbf, 0x2e, 0x8d, 0xe3, 0x4a, 0xab, 0xcb, 0x66, 0x3a, 0x8a, 0x08, 0x08, 0x31, 0x07, 0x73, 0xa2,
	0x5e, 0xa1, 0x43, 0x28, 0x20, 0x33, 0xea, 0x47, 0x6e, 0x56, 0xa4, 0x1e, 0xc9, 0xb5, 0x9d, 0x53,
	0x69, 0x34, 0xb0, 0x4f, 0xd6, 0xa5, 0xa1, 0xb5, 0x38, 0xda, 0x25, 0xa6, 0x73, 0x20, 0x62, 0x17,
	0x22, 0xf4, 0x1e, 0x22, 0x7f, 0x98, 0xbc, 0x84, 0xfa, 0x53, 0x37, 0x22, 0x71, 0x18, 0x71, 0x6d,
	0x70, 0x2a, 0x8d, 0x76, 0xee, 0x30, 0xb5, 0x4b, 0x6a, 0x26, 0x5b, 0x84, 0xae, 0xaa, 0xc8, 0xd7,
	0x01, 0x42, 0x60, 0x90, 0xf8, 0x34, 0x0f, 0xd4, 0x09, 0x52, 0x3a, 0xee, 0x24, 0x70, 0xf7, 0xb8,
	0x39, 0xcd, 0xae, 0xb1, 0x21, 0x69, 0x99, 0x9a, 0x20, 0xa5, 0xe3, 0xa7, 0x0f, 0x7e, 0x5a, 0x7b,
	0xbb, 0x56, 0x86, 0x5e, 0x63, 0x43, 0x9d, 0xa2, 0xbd, 0xaa, 0x43, 0x2e, 0x4e, 0x69, 0x91, 0x71,
	0x38, 0x16, 0xd9, 0xbe, 0xdc, 0xba, 0xe9, 0x47, 0xb5, 0x54, 0x9b, 0xcc, 0x74, 0x94, 0x0a, 0xbf,
	0x02, 0xa8, 0xba, 0x48, 0x6e, 0x3a, 0x3e, 0x00, 0x21, 0x7b, 0xeb, 0x8e, 0x3f, 0x68, 0x84, 0xea,
	0x66, 0xdf, 0xf7, 0x36, 0x8d, 0x4e, 0xd1, 0x7e, 0x88, 0x99, 0x5b, 0x30, 0x1c, 0x92, 0x4a, 0xe5,
	0xde, 0xbf, 0xcd, 0x55, 0x97, 0xcd, 0x74, 0x94, 0x10, 0xb3, 0x8f, 0x02, 0x83, 0x9c, 0x87, 0x50,
	0x35, 0xe4, 0x9f, 0x09, 0x61, 0xda, 0x2e, 0x48, 0xbd, 0xde, 0xfa, 0xe4, 0x0e, 0xdb, 0xd7, 0x45,
	0x30, 0x99, 0x8e, 0x0c, 0xe0, 0x52, 0xac, 0xbf, 0xf5, 0xd1, 0xc1, 0x3b, 0x9a, 0xf1, 0x28, 0x59,
	0x88, 0x71, 0x39, 0xc7, 0x1c, 0xab, 0x2f, 0xd1, 0x30, 0x15, 0x21, 0x37, 0xce, 0x02, 0x32, 0x87,
	0x59, 0xd9, 0xb3, 0x1f, 0xad, 0x4b, 0x43, 0xad, 0xa8, 0x5a, 0x49, 0xd3, 0x41, 0x80, 0xae, 0x05,
	0xb8, 0xdb, 0xed, 0xfe, 0x7f, 0xec, 0xf6, 0x04, 0x29, 0x8c, 0xe3, 0x9c, 0x6f, 0xc6, 0x72, 0xe7,
	0xef, 0xb1, 0x6c, 0x67, 0x4d, 0x67, 0x08, 0xb0, 0x1e, 0xcb, 0x17, 0x08, 0x91, 0x2c, 0xe8, 0x5e,
	0xb0, 0xe3, 0xe6, 0xac, 0x9a, 0x9c, 0xe9, 0xc8, 0x24, 0x0b, 0xaa, 0x5d, 0xf6, 0xdb, 0x9b, 0xa5,
	0x2e, 0xdd, 0x2e, 0x75, 0xe9, 0xe7, 0x52, 0x97, 0xbe, 0xac, 0xf4, 0xde, 0xed, 0x4a, 0xef, 0x7d,
	0x5f, 0xe9, 0xbd, 0x4f, 0xcf, 0x5a, 0x5f, 0xc6, 0x48, 0x7c, 0xb6, 0x79, 0x28, 0x01, 0xc0, 0x4b,
	0x69, 0xcd, 0xad, 0xcd, 0xa3, 0x0a, 0x1f, 0xea, 0xed, 0x42, 0xcd, 0xf3, 0xdf, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xc8, 0xcf, 0x32, 0xb5, 0x6c, 0x05, 0x00, 0x00,
}

func (m *BurnStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastBlockHeight != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.LastBlockHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.LastEpochNumber != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.LastEpochNumber))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.LastBurnRate.Size()
		i -= size
		if _, err := m.LastBurnRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TotalBurned.Size()
		i -= size
		if _, err := m.TotalBurned.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BurnRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.TotalFees.Size()
		i -= size
		if _, err := m.TotalFees.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.GasUsageRate.Size()
		i -= size
		if _, err := m.GasUsageRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.BurnRate.Size()
		i -= size
		if _, err := m.BurnRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.BurnedAmount.Size()
		i -= size
		if _, err := m.BurnedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.BlockHeight != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochNumber != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MonthlyBurnData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonthlyBurnData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonthlyBurnData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndHeight != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.StartHeight != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.BurnedAmount.Size()
		i -= size
		if _, err := m.BurnedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBurn(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.MonthIndex != 0 {
		i = encodeVarintBurn(dAtA, i, uint64(m.MonthIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBurn(dAtA []byte, offset int, v uint64) int {
	offset -= sovBurn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BurnStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalBurned.Size()
	n += 1 + l + sovBurn(uint64(l))
	l = m.LastBurnRate.Size()
	n += 1 + l + sovBurn(uint64(l))
	if m.LastEpochNumber != 0 {
		n += 1 + sovBurn(uint64(m.LastEpochNumber))
	}
	if m.LastBlockHeight != 0 {
		n += 1 + sovBurn(uint64(m.LastBlockHeight))
	}
	return n
}

func (m *BurnRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovBurn(uint64(m.EpochNumber))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovBurn(uint64(m.BlockHeight))
	}
	l = m.BurnedAmount.Size()
	n += 1 + l + sovBurn(uint64(l))
	l = m.BurnRate.Size()
	n += 1 + l + sovBurn(uint64(l))
	l = m.GasUsageRate.Size()
	n += 1 + l + sovBurn(uint64(l))
	l = m.TotalFees.Size()
	n += 1 + l + sovBurn(uint64(l))
	return n
}

func (m *MonthlyBurnData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonthIndex != 0 {
		n += 1 + sovBurn(uint64(m.MonthIndex))
	}
	l = m.BurnedAmount.Size()
	n += 1 + l + sovBurn(uint64(l))
	if m.StartHeight != 0 {
		n += 1 + sovBurn(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovBurn(uint64(m.EndHeight))
	}
	return n
}

func sovBurn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBurn(x uint64) (n int) {
	return sovBurn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BurnStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBurn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBurned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalBurned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBurnRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastBurnRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEpochNumber", wireType)
			}
			m.LastEpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastEpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockHeight", wireType)
			}
			m.LastBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBurn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBurn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBurn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsageRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasUsageRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFees", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFees.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBurn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBurn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonthlyBurnData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBurn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonthlyBurnData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonthlyBurnData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthIndex", wireType)
			}
			m.MonthIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MonthIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBurn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBurn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBurn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBurn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBurn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBurn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBurn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBurn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBurn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBurn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBurn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBurn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBurn = fmt.Errorf("proto: unexpected end of group")
)
